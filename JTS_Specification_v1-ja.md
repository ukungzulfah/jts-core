
# プロジェクトアーカイブドキュメント：Janusトークンシステム（JTS）

**タイトル：** Janusトークンシステム（JTS）：安全で取消可能、かつ機密性の高いAPI認証のための2コンポーネントアーキテクチャ

**ステータス：** 標準ドラフト、バージョン1.1

**著者/パイオニア：** ukungzulfah

**公開日：** 2025年11月30日

> **概要：**
> このドキュメントでは、現代の分散アプリケーションエコシステム（例：マイクロサービスアーキテクチャ）におけるセキュリティとスケーラビリティの課題に対処するために設計された新しい認証標準である **Janusトークンシステム（JTS）** を定義します。JTSは、**短期的なアクセス証明（`BearerPass`）** と **長期的なセッション証明（`StateProof`）** を根本的に分離する2コンポーネントアーキテクチャを導入しています。このアプローチにより、即時セッション取消を含む、*ステートフル*なセッション管理の重要な能力を維持しつつ、非常に高速で*ステートレス*なアクセス検証が可能になります。このドキュメントでは、3つの運用プロファイルを定義します：完全なセキュリティ機能を備えた完全な整合性のための **JTS-S（標準）**、最小限の複雑さで軽量な実装のための **JTS-L（ライト）**、そして完全なペイロードの機密性のための **JTS-C（機密性）** です。この仕様はまた、直感的でない従来の用語を置き換えるための新しいクレーム用語を導入します。

---

### **著作権ライセンス**
> Copyright © 2025, ukungzulfah. All Rights Reserved.
>
> 本仕様書および関連ドキュメント（「本ソフトウェア」）のコピーを取得するすべての人に、以下の条件に従って、本ソフトウェアのコピーを使用、複製、変更、結合、公開、配布、および/または販売する権利を無料で許諾します：
>
> 上記の著作権表示とこの許可表示は、本ソフトウェアのすべてのコピーまたは実質的な部分に含まれるものとします。本ソフトウェアは「現状のまま」提供され、明示または黙示を問わず、いかなる保証もありません。

---

### **1. はじめに**

#### **1.1. 現代の認証における課題**
現代のソフトウェアアーキテクチャでは、アプリケーションは小さく独立したサービス（マイクロサービス）に分割されています。このモデルでは、軽量で分散型であり、単一のモノリシックな集中セッションに依存しない認証システムが求められます。

#### **1.2. 初期のステートレストークンモデルの限界**
第一世代のステートレスなトークンベースの認証モデルは部分的な解決策を提供しましたが、重大な弱点も導入しました：
1.  **セッション取消の脆弱性：** 発行されたトークンは、有効期限が切れる前にサーバー側から強制的に無効にすることはできません。
2.  **情報漏洩：** トークンのペイロードは暗号化されずに単にエンコードされていることが多いため、トークンを保持する أي طرفが内部データを読み取ることができます。
3.  **キー管理の複雑さ：** 共有対称キーの使用は、分散環境において高リスクの単一障害点を生み出します。

#### **1.3. 新しいパラダイム：Janusトークンシステム（JTS）**
JTSは、これらの弱点に対処するための進化として提案されています。その二元性の原則により、JTSは*ステートレス*な効率性と*ステートフル*なセキュリティを兼ね備えています。

### **2. JTSのコアコンセプト**

#### **2.1. 二元性の原則**
JTSはトークンの役割を2つに分離します：
1.  **アクセス：** 非常に短い期間、リソースへのアクセス許可を与える。
2.  **セッション：** ユーザーの全体的な認証セッションの有効性を証明する。

#### **2.2. JTSの2つのコンポーネント**
1.  **`BearerPass`：** 暗号署名された短命のアクセストークン。すべてのAPIリクエストで使用され、ステートレスに検証されます。
2.  **`StateProof`：** 不透明でステートフルな長命のセッショントークン。新しい`BearerPass`を取得するために排他的に使用され、クライアント側で安全に保存されます。サーバーのデータベースに存在することがセッションの有効性を決定します。

### **3. JTSの用語とクレーム**

洗練として、JTSはあいまいな従来の用語から離れ、より明示的で直感的なクレーム用語を導入します。

| JTSクレーム | フルネーム | 説明 | 代替 |
| :--- | :--- | :--- | :--- |
| **`prn`** | **Principal** | 認証されたプリンシパル（通常はユーザー）の一意の識別子。 | `sub` |
| **`aid`** | **Anchor ID** | `BearerPass`をサーバー上のセッションレコードに「固定」する一意のID。 | `sid` |
| **`tkn_id`**| **Token ID** | 各`BearerPass`の一意の識別子で、リプレイ攻撃を防ぎます。 | `jti` |
| `exp` | Expiration Time | トークンの有効期限（RFC 7519から維持）。 | - |
| `aud` | Audience | このトークンの意図された受信者（RFC 7519から維持）。 | - |
| `iat` | Issued At | トークンが発行された時刻（RFC 7519から維持）。 | - |

#### **3.2. 拡張クレーム**

JTSは、より堅牢なセキュリティと機能性のために追加のクレームを定義します：

| JTSクレーム | フルネーム | 説明 | 必須 |
| :--- | :--- | :--- | :--- |
| **`dfp`** | **Device Fingerprint** | トークンを特定のデバイスにバインドするためのデバイス特性のハッシュ。 | いいえ |
| **`perm`**| **Permissions** | トークンが保持する権限/スコープを定義する文字列の配列。 | いいえ |
| **`grc`** | **Grace Period** | `exp`後の飛行中のリクエストのための時間的許容範囲（秒）。 | いいえ |
| **`org`** | **Organization** | マルチテナントシステムのテナント/組織識別子。 | いいえ |
| **`atm`** | **Auth Method** | 使用された認証方法（例：`pwd`、`mfa:totp`、`sso`）。 | いいえ |
| **`ath`** | **Auth Time** | ユーザーが最後にアクティブな認証を実行したUnixタイムスタンプ。 | いいえ |
| **`spl`** | **Session Policy** | 有効な同時セッションポリシー（`allow_all`、`single`、`max:n`）。 | いいえ |

**拡張クレーム付きのペイロード例：**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "tkn_id": "token-instance-98765",
  "aud": "https://api.example.com/billing",
  "exp": 1764515700,
  "iat": 1764515400,
  "dfp": "sha256:a1b2c3d4e5f6...",
  "perm": ["read:profile", "write:posts", "billing:view"],
  "grc": 30,
  "org": "tenant-acme-corp",
  "atm": "mfa:totp",
  "ath": 1764512000
}
```

### **4. 標準プロファイル：JTS-S（整合性）**

このプロファイルは、速度、整合性、およびセッション取消機能に焦点を当てています。

#### **4.1. `BearerPass`の構造（JWS形式）**
JTS-Sプロファイルの`BearerPass`は、**非対称暗号（例：RS256）**で署名された**JSON Web Signature（JWS）**です。

**ヘッダー例：**
```json
{
  "alg": "RS256",
  "typ": "JTS-S/v1",
  "kid": "auth-server-key-2025-001"
}
```

**注意：** `kid`（キーID）クレームは、キーのローテーションをサポートするために必須です（セクション7を参照）。

**ペイロード例：**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "tkn_id": "token-instance-98765",
  "aud": "https://api.example.com/billing",
  "exp": 1764515700,
  "iat": 1764515400
}
```

#### **4.2. ワークフロー**
1.  **認証：** ユーザーがログイン -> サーバーがDBにセッションレコードを作成し、`StateProof`（DBに保存）と`BearerPass`（JWS）を生成します。`StateProof`は`HttpOnly`クッキーを介して送信され、`BearerPass`はJSONボディを介して送信されます。
2.  **リソースアクセス：** クライアントがヘッダーで`BearerPass`を送信 -> サーバーが公開鍵を使用してJWS署名を検証します。
3.  **更新：** `BearerPass`が期限切れ -> クライアントがクッキー内の`StateProof`を使用して`/renew`エンドポイントを呼び出す -> サーバーがDBで`StateProof`を検証し、有効であれば新しい`BearerPass`を発行します。
4.  **取消（ログアウト）：** クライアントが`/logout`を呼び出す -> サーバーが`StateProof`に関連付けられたセッションレコードをDBから削除します。セッションは即座に無効になります。

#### **4.3. クッキーの要件とCSRF保護**

クッキーに保存された`StateProof`は、以下のセキュリティ要件を満たす必要があります：

**必須のクッキー属性：**
```
Set-Cookie: jts_state_proof=<token>; 
  HttpOnly; 
  Secure; 
  SameSite=Strict; 
  Path=/jts; 
  Max-Age=604800
```

| 属性 | 値 | 説明 |
| :--- | :--- | :--- |
| `HttpOnly` | 必須 | JavaScriptからのアクセスを防ぎます（XSSを軽減）。 |
| `Secure` | 必須 | クッキーはHTTPS経由でのみ送信されます。 |
| `SameSite` | `Strict` | クロスサイトリクエストでのクッキーの送信を防ぎます（CSRFを軽減）。 |
| `Path` | `/jts` | クッキーがJTSエンドポイントにのみ送信されるように制限します。 |
| `Max-Age` | ポリシーによる | セッションポリシーに応じたクッキーの寿命。 |

**追加のCSRF保護：**

`/renew`および`/logout`エンドポイントに対して、サーバーは以下のメカニズムの少なくとも1つを検証する必要があります：

1.  **Originヘッダーの検証：** `Origin`または`Referer`ヘッダーが許可されたドメインから来ていることを確認します。
2.  **カスタムヘッダーの要件：** 標準のフォーム送信では設定できないカスタムヘッダーを要求します：
    ```
    X-JTS-Request: 1
    ```
3.  **ダブルサブミットクッキーパターン：** CSRFトークン値をクッキーとリクエストボディ/ヘッダーの両方で送信し、それらが一致することを検証します。

#### **4.4. StateProofのローテーション**

セキュリティを強化し、トークンの盗難を検出するために、JTSはすべての更新操作で`StateProof`のローテーションを要求します。

**メカニズム：**
1.  クライアントが古い`StateProof`で`/renew`を呼び出します。
2.  サーバーがデータベースで古い`StateProof`を検証します。
3.  有効な場合：
    a.  サーバーは古い`StateProof`を削除または*消費済み*としてマークします。
    b.  サーバーは新しい`StateProof`と新しい`BearerPass`を発行します。
    c.  新しい`StateProof`は`Set-Cookie`ヘッダーを介して送信されます。
4.  古い`StateProof`がすでに*消費済み*としてマークされている場合（リプレイが検出された場合）：
    a.  サーバーはその`aid`に関連するすべてのセッションを即座に無効にする必要があります。
    b.  サーバーは`JTS-401-05`（セッションが侵害された）エラーを返す必要があります。
    c.  サーバーはユーザーにセキュリティ通知を送信する必要があります。

**ローテーション図：**
```
[クライアント]                         [認証サーバー]                  [データベース]
    |                                       |                               |
    |-- POST /renew (StateProof_v1) ------->|                               |
    |                                       |-- StateProof_v1を検証 ---->|
    |                                       |<-- 有効、消費済みとしてマーク ---|
    |                                       |                               |
    |                                       |-- StateProof_v2を生成 ---->|
    |                                       |<-- 保存済み --------------------|
    |                                       |                               |
    |<-- 200 OK (新しいBearerPass) ----------|                               |
    |<-- Set-Cookie: StateProof_v2 ---------|                               |
    |                                       |                               |
```

**異常検出（リプレイ攻撃）：**
```
[攻撃者]                            [認証サーバー]                  [データベース]
    |                                       |                               |
    |-- POST /renew (StateProof_v1) ------->|  (盗まれたトークン)             |
    |                                       |-- StateProof_v1を検証 ---->|
    |                                       |<-- 消費済み！リプレイが検出されました -|
    |                                       |                               |
    |                                       |-- すべてのセッションを取消 (aid) ->|
    |                                       |<-- 完了 ----------------------|
    |                                       |                               |
    |<-- 401 JTS-401-05 (侵害された) --------|
    |                                       |                               |
```

#### **4.5. 同時更新における競合状態の処理**

ユーザーが複数のタブ/ウィンドウを持っている場合や、更新リクエストがほぼ同時に発生する場合、*偽陽性*のリプレイ検出のリスクがあります。JTSは、この状態を処理するために**ローテーショングレースウィンドウ**メカニズムを定義します。

**問題：**
```
[タブA]                                [認証サーバー]                  [データベース]
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- SP_v1を消費済みとしてマーク -->|
    |                                     |                               |
[タブB]  (少し遅れて)                 |                               |
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- SP_v1をチェック -------------->|
    |                                     |<-- 消費済み！ (偽陽性) |
    |<-- 401 JTS-401-05 ??? --------------|  (ユーザーは侵害されていない！)      |
```

**解決策：ローテーショングレースウィンドウ**

サーバーは、以下の仕様で**ローテーショングレースウィンドウ**を実装する必要があります：

1.  **グレースウィンドウの期間：** サーバーはローテーション後**5〜10秒間**、`previous_state_proof`を保存する必要があります。
2.  **二重検証：** グレースウィンドウ中、サーバーは`current_state_proof`と`previous_state_proof`の両方を受け入れる必要があります。
3.  **前のトークンへの応答：** リクエストがまだグレースウィンドウ内にある`previous_state_proof`を使用する場合：
    -   サーバーは、`current_state_proof`に対してすでに生成された同じ`StateProof`と`BearerPass`を返す必要があります。
    -   サーバーは新しいトークンを生成してはなりません（トークンの分岐を防ぎます）。
4.  **グレースウィンドウ後：** グレースウィンドウを過ぎた`previous_state_proof`を持つリクエストは、リプレイ攻撃として扱われる必要があります。

**データベース実装：**
```sql
CREATE TABLE jts_sessions (
    aid                   VARCHAR(64) PRIMARY KEY,
    prn                   VARCHAR(128) NOT NULL,
    current_state_proof   VARCHAR(256) NOT NULL,
    previous_state_proof  VARCHAR(256),           -- 前のトークン
    rotation_timestamp    TIMESTAMP,              -- 最後のローテーションが発生したとき
    -- ... 他の列
);
```

**検証ロジック：**
```
function validate_state_proof(incoming_sp):
    session = db.find_by_current_sp(incoming_sp)
    if session:
        return VALID, session
    
    session = db.find_by_previous_sp(incoming_sp)
    if session:
        grace_window = 10 seconds
        if now() - session.rotation_timestamp < grace_window:
            return VALID_WITHIN_GRACE, session  // 既存のトークンを返す
        else:
            trigger_replay_detection(session.aid)
            return REPLAY_DETECTED, null
    
    return INVALID, null
```

**同時更新図（処理済み）：**
```
[タブA]                                [認証サーバー]                  [データベース]
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- ローテーション: SP_v1 -> SP_v2 ---->|
    |                                     |   (previous=SP_v1を保存)      |
    |<-- 200 OK (新しいBP, SP_v2) ---------|                               |
    |                                     |                               |
[タブB]  (10秒以内)                    |                               |
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- SP_v1をチェック -------------->|
    |                                     |<-- previous_spで発見、      |
    |                                     |    グレースウィンドウ内 -------|
    |<-- 200 OK (新しいBP, SP_v2) ---------|  (タブAと同じトークン)       |
    |                                     |                               |
```

> **注意：** 両方のタブは अब 同じ`StateProof`（SP_v2）を持ち、同期されたままです。

#### **4.6. 飛行中のリクエストのための猶予期間**

`BearerPass`がリクエストの飛行中に期限切れになる競合状態を処理するため：

**仕様：**
-   リソースサーバーは、`exp`時間の後に時間的許容範囲（*猶予期間*）を提供してもよい。
-   猶予期間は**60秒**を超えてはならない。
-   ペイロードに`grc`クレームが存在する場合、その値が猶予期間を秒単位で定義します。
-   `grc`クレームが存在しない場合、デフォルトの猶予期間は**0秒**です（許容範囲なし）。

**検証ロジック：**
```
current_time = now()
effective_expiry = token.exp + token.grc (or 0 if grc is not present)

if current_time > effective_expiry:
    return ERROR_TOKEN_EXPIRED
else:
    return VALID
```

**注意：** 猶予期間は、監査目的でトークンの寿命を延長するものではありません。元の`exp`時間は、ロギングのために引き続き使用されます。

### **5. ライトプロファイル：JTS-L（Lite）**

このプロファイルは、JTSのコアセキュリティ原則を犠牲にすることなく実装の容易さを必要とする低複雑度のユースケース向けに設計されています。

#### **5.1. JTS-Lを使用する場合**

JTS-Lは、以下のシナリオに適しています：

| シナリオ | 推奨 | 理由 |
| :--- | :--- | :--- |
| スタートアップのMVP/プロトタイプ | ✅ JTS-L | 実装が迅速で、後でJTS-Sにアップグレード可能。 |
| 内部ツール/管理パネル | ✅ JTS-L | ユーザーベースが小さく、リスクが低い。 |
| シンプルなシングルページアプリケーション | ✅ JTS-L | 複雑なリプレイ検出は不要。 |
| 機密データを含む公開API | ❌ JTS-Sを使用 | リプレイ保護とデバイスバインディングが必要。 |
| フィンテック/ヘルスケア | ❌ JTS-S/Cを使用 | 最大限のコンプライアンスとセキュリティが必要。 |
| マルチテナントSaaS | ❌ JTS-Sを使用 | 分離と完全な監査証跡が必要。 |

#### **5.2. JTS-Sとの主な違い**

| 機能 | JTS-S（標準） | JTS-L（ライト） |
| :--- | :--- | :--- |
| StateProofのローテーション | ✅ `/renew`ごとに必須 | ❌ オプション |
| リプレイ検出 | ✅ 消費済みマーキングによる組み込み | ⚠️ 手動/なし |
| デバイスフィンガープリント（`dfp`） | ✅ 推奨 | ❌ 不要 |
| 猶予期間（`grc`） | ✅ サポート | ✅ サポート |
| 拡張クレーム | ✅ 完全 | ⚠️ 最小サブセット |
| 同時セッションポリシー | ✅ 完全 | ⚠️ `allow_all`のみ |
| データベースの複雑さ | 高（消費済みトークンの追跡） | 低（単純なセッションテーブル） |
| エラーコード | 完全（すべてのコード） | 必須サブセット |

#### **5.3. JTS-Lの`BearerPass`構造**

JTS-Lの`BearerPass`は、依然として**非対称暗号を使用したJWS**を使用しますが、よりミニマリストなペイロードです。

**ヘッダー：**
```json
{
  "alg": "RS256",
  "typ": "JTS-L/v1",
  "kid": "auth-server-key-2025-001"
}
```

**最小ペイロード：**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "exp": 1764515700,
  "iat": 1764515400
}
```

**注意：** リプレイ検出が不要なため、JTS-Lでは`tkn_id`クレームは**オプション**です。

#### **5.4. JTS-Lワークフロー（簡略版）**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        JTS-Lの簡略化されたフロー                             │
└─────────────────────────────────────────────────────────────────────────────┘

[クライアント]                         [認証サーバー]                  [データベース]
    │                                       |                               |
    │── POST /login (資格情報) ─────────>│                               |
    │                                       │── セッションを作成 ────────────>│
    │                                       │<── セッションID ────────────────│
    │<── 200 OK ────────────────────────────│                               |
    │    BearerPass (ボディ)                  │                               |
    │    StateProof (クッキー)                │                               |
    │                                       │                               |
    │   ... BearerPassの有効期限切れ ...      │                               |
    │                                       │                               |
    │── POST /renew (StateProof) ──────────>│                               |
    │                                       │── セッションの存在を確認 ──────>│
    │                                       │<── 有効 ─────────────────────│
    │                                       │   (ローテーションなし, 消費済みなし)  │
    │<── 200 OK ────────────────────────────│                               |
    │    新しいBearerPass (ボディ)              │                               |
    │    (StateProofは変更なし)             │                               |
    │                                       │                               |
```

**主な違い：**
-   `StateProof`は`/renew`ごとに**ローテーションされません**—セッションがアクティブである限り、同じトークンを複数回使用できます。
-   サーバーは、「消費済み」ステータスを追跡する必要なく、データベースにセッションレコードが**存在**するかどうかを確認するだけです。
-   データベースの複雑さが大幅に軽減されます。

#### **5.5. JTS-Lのデータベーススキーマ**

JTS-Lのデータベースははるかに単純です：

```sql
-- JTS-L: シンプルなセッションテーブル
CREATE TABLE jts_sessions (
    aid             VARCHAR(64) PRIMARY KEY,  -- Anchor ID (StateProof)
    prn             VARCHAR(128) NOT NULL,    -- プリンシパル (ユーザーID)
    created_at      TIMESTAMP DEFAULT NOW(),
    expires_at      TIMESTAMP NOT NULL,
    last_active     TIMESTAMP DEFAULT NOW(),
    user_agent      TEXT,                     -- オプション: セッションリスト用
    ip_address      VARCHAR(45)               -- オプション: 監査用
);

-- ユーザーによるクエリ用のインデックス
CREATE INDEX idx_sessions_prn ON jts_sessions(prn);
```

**JTS-Sが必要とするものと比較してください：**
```sql
-- JTS-S: ローテーショントラッキング付きの完全なセッションテーブル
CREATE TABLE jts_sessions (
    aid                  VARCHAR(64) PRIMARY KEY,
    prn                  VARCHAR(128) NOT NULL,
    current_state_proof  VARCHAR(256) NOT NULL,
    previous_state_proof VARCHAR(256),        -- グレースウィンドウ用
    state_proof_version  INTEGER DEFAULT 1,
    consumed_at          TIMESTAMP,             -- リプレイ検出
    device_fingerprint   VARCHAR(128),
    created_at           TIMESTAMP DEFAULT NOW(),
    expires_at           TIMESTAMP NOT NULL,
    last_active          TIMESTAMP DEFAULT NOW(),
    -- ... その他の列
);

-- 消費済みトークンを追跡するための追加テーブル
CREATE TABLE jts_consumed_tokens (
    tkn_id          VARCHAR(64) PRIMARY KEY,
    aid             VARCHAR(64) REFERENCES jts_sessions(aid),
    consumed_at     TIMESTAMP DEFAULT NOW()
);
```

#### **5.6. JTS-Lのエラーコードのサブセット**

JTS-Lは、以下のエラーコードのサブセットのみを実装する必要があります：

| エラーコード | エラーキー | 説明 |
| :--- | :--- | :--- |
| `JTS-400-01` | `malformed_token` | トークンを解析できませんでした。 |
| `JTS-401-01` | `bearer_expired` | BearerPassの有効期限が切れています。 |
| `JTS-401-02` | `signature_invalid` | 署名が無効です。 |
| `JTS-401-03` | `stateproof_invalid` | StateProofが無効です。 |
| `JTS-401-04` | `session_terminated` | セッションは終了しました。 |

**JTS-Lでは以下のエラーコードは不要です：**
-   `JTS-401-05` (session_compromised) — リプレイ検出なし
-   `JTS-401-06` (device_mismatch) — デバイスバインディングなし
-   `JTS-403-03` (org_mismatch) — マルチテナントサポートなし

#### **5.7. JTS-LからJTS-Sへの移行**

JTS-Lは、セキュリティニーズが高まるにつれてJTS-Sに簡単にアップグレードできるように設計されています：

**移行手順：**

1.  **ヘッダータイプの更新：**
    ```json
    // 以前
    { "typ": "JTS-L/v1" }
    // 以後
    { "typ": "JTS-S/v1" }
    ```

2.  **データベース列の追加：**
    ```sql
    ALTER TABLE jts_sessions 
    ADD COLUMN current_state_proof VARCHAR(256),
    ADD COLUMN state_proof_version INTEGER DEFAULT 1,
    ADD COLUMN consumed_at TIMESTAMP,
    ADD COLUMN device_fingerprint VARCHAR(128);
    ```

3.  **StateProofローテーションの実装：** `/renew`ロジックを更新して、新しいStateProofを生成します。

4.  **ペイロードに`tkn_id`を追加：** 各BearerPassに一意のトークンIDを生成し始めます。

5.  **段階的なロールアウト：**
    -   フェーズ1：サーバーがJTS-LとJTS-Sの両方のトークンを受け入れる
    -   フェーズ2：すべての新しいトークンがJTS-Sになる
    -   フェーズ3：最大セッション寿命後にJTS-Lトークンを拒否する

#### **5.8. JTS-Lの制限とリスク**

> ⚠️ **警告：** 実装者は、JTS-Lを選択する前に以下のリスクを理解する必要があります：

| リスク | 影響 | 緩和策 |
| :--- | :--- | :--- |
| **リプレイ検出なし** | 盗まれたStateProofは検出されずに複数回使用できます。 | セッションに短い`exp`を使用します。 |
| **デバイスバインディングなし** | トークンは別のデバイスから使用できます。 | IPベースのレート制限を実装します。 |
| **盗難が検出されない** | ユーザーのトークンが盗まれても通知されません。 | ログインパターンを監視し、新しいIPで通知します。 |

**JTS-Lの緩和策の推奨事項：**
-   `StateProof`の有効期限を短く設定する（JTS-Sの7日に対して最大24時間）
-   `/renew`エンドポイントにレート制限を実装する
-   手動監査のためにすべての更新アクティビティをログに記録する
-   新しいIP/場所からのログインに対してメール通知を検討する

---

### **6. 機密性プロファイル：JTS-C（Confidentiality）**

このプロファイルは、完全なペイロードの機密性のために暗号化レイヤーを追加します。

#### **6.1. `BearerPass`の構造（JWE形式）**
JTS-Cプロファイルの`BearerPass`は、**JSON Web Encryption（JWE）**です。標準プロファイルのJWSトークンは、JWEに「ラップ」または暗号化されます。

#### **6.2. ワークフロー**
*   **トークン作成（「署名してから暗号化」）：**
    1.  JTS-SプロファイルのようにJWSを作成します。
    2.  意図したリソースサーバーの**公開鍵**を使用してJWS全体を暗号化します。結果はJWEです。
*   **トークン検証（「復号してから検証」）：**
    1.  リソースサーバーがJWEを受信します。
    2.  サーバーは**自身の秘密鍵**を使用してJWEを復号します。結果は元のJWSです。
    3.  サーバーは**認証サーバーの公開鍵**を使用してJWSを検証します。

### **7. セキュリティ分析とエラー処理**

#### **7.1. セキュリティ分析**

*   **セッション取消：** サーバーのデータベースでの`StateProof`の管理を通じて完全に解決されます。
*   **資格情報の漏洩：** 非対称暗号の必須使用と`HttpOnly`クッキーでの`StateProof`の保護により最小化されます。
*   **情報漏洩：** JTS-S/JTS-Lでは最小限のペイロードで最小化され、JTS-CではJWE暗号化を通じて完全に解決されます。
*   **リプレイ攻撃：** JTS-Sでは一意の`tkn_id`と**StateProofのローテーション**で軽減されます。**注意：** JTS-Lは自動リプレイ保護を提供しません。
*   **XSS攻撃：** クッキーの`HttpOnly`フラグにより、`StateProof`セッショントークンの盗難リスクが大幅に減少します。
*   **CSRF攻撃：** `SameSite=Strict`と追加のヘッダー検証の組み合わせで軽減されます。
*   **トークン盗難：** JTS-Sでは**デバイスフィンガープリント（`dfp`）**で軽減されます。**注意：** JTS-Lはデバイスバインディングをサポートしません。

#### **7.2. 標準エラーコード**

JTSは、実装の一貫性とデバッグの容易さのために標準エラーコードを定義します：

**エラー応答形式：**
```json
{
  "error": "bearer_expired",
  "error_code": "JTS-401-01",
  "message": "BearerPass has expired",
  "action": "renew",
  "retry_after": 0,
  "timestamp": 1764515800
}
```

**エラーコードのリスト：**

| エラーコード | HTTPステータス | エラーキー | 説明 | アクション |
| :--- | :--- | :--- | :--- | :--- |
| `JTS-400-01` | 400 | `malformed_token` | トークンが解析できないか、形式が無効です。 | `reauth` |
| `JTS-400-02` | 400 | `missing_claims` | 必要なクレームがトークンにありません。 | `reauth` |
| `JTS-401-01` | 401 | `bearer_expired` | BearerPassの有効期限が切れています。 | `renew` |
| `JTS-401-02` | 401 | `signature_invalid` | BearerPassの署名が無効です。 | `reauth` |
| `JTS-401-03` | 401 | `stateproof_invalid` | StateProofが無効か、DBに見つかりません。 | `reauth` |
| `JTS-401-04` | 401 | `session_terminated` | セッションは終了しました（ログアウトまたは同時ポリシー）。 | `reauth` |
| `JTS-401-05` | 401 | `session_compromised`| リプレイ攻撃が検出されました。すべてのセッションが取り消されます。| `reauth` |
| `JTS-401-06` | 401 | `device_mismatch` | デバイスフィンガープリントが一致しません。 | `reauth` |
| `JTS-403-01` | 403 | `audience_mismatch` | トークンはこのリソース向けではありません。 | `none` |
| `JTS-403-02` | 403 | `permission_denied` | トークンに必要な権限がありません。 | `none` |
| `JTS-403-03` | 403 | `org_mismatch` | トークンは別の組織/テナントに属しています。 | `none` |
| `JTS-500-01` | 500 | `key_unavailable` | 検証用の公開鍵が利用できません。 | `retry` |

**アクション値：**
-   `renew`：クライアントは`/renew`エンドポイントを呼び出して新しいBearerPassを取得する必要があります。
-   `reauth`：ユーザーは再認証（ログイン）する必要があります。
-   `retry`：リクエストは`retry_after`秒後に再試行できます。
-   `none`：この状態を修正するアクションはありません。

### **8. キー管理**

#### **8.1. キーIDの要件**

すべての`BearerPass`は、署名に使用されたキーを識別するために、ヘッダーに`kid`（キーID）クレームを含める必要があります。

**kid付きのヘッダー形式：**
```json
{
  "alg": "RS256",
  "typ": "JTS-S/v1",
  "kid": "auth-server-key-2025-001"
}
```

#### **8.2. キーローテーション手順**

既に発行されたトークンを無効にせずに署名キーを交換するには：

**手順：**
1.  **新しいキーペアの生成：** 一意の`kid`を持つ新しいキーペアを作成します。
2.  **公開鍵の公開：** 新しい公開鍵をJWKSエンドポイントに追加します。サーバーは複数のアクティブな公開鍵をサポートする必要があります。
3.  **新しいキーでの署名開始：** すべての新しい`BearerPass`トークンは新しいキーで署名されます。
4.  **古いキーの廃止：** `max_bearer_lifetime` + バッファ（推奨：15分）後、古い公開鍵をJWKSから削除します。

**JWKSエンドポイントの応答：**
```json
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "auth-server-key-2025-002",
      "use": "sig",
      "alg": "RS256",
      "n": "...",
      "e": "AQAB"
    },
    {
      "kty": "RSA",
      "kid": "auth-server-key-2025-001",
      "use": "sig",
      "alg": "RS256",
      "n": "...",
      "e": "AQAB",
      "exp": 1764520000
    }
  ]
}
```

**注意：** キーエントリの`exp`フィールドは、キーが廃止される時期を示します（オプション、クライアント情報用）。

#### **8.3. 標準JWKSエンドポイント**

JTSは、リソースサーバーが公開鍵を一貫して見つけられるように、JWKS（JSON Web Key Set）エンドポイントの標準パスを定義します。

**標準パス：**
```
GET /.well-known/jts-jwks
```

**要件：**

| 側面 | 仕様 |
| :--- | :--- |
| **パス** | `/.well-known/jts-jwks` (必須) |
| **メソッド** | `GET` |
| **認証** | 不要（公開エンドポイント） |
| **Content-Type** | `application/json` |
| **CORS** | 有効なドメインからのクロスオリジンリクエストを許可する必要があります |

**キャッシング：**

サーバーは適切なキャッシングヘッダーを含める必要があります：

```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: public, max-age=3600, stale-while-revalidate=60
ETag: "jwks-v2-abc123"
```

| ヘッダー | 推奨値 | 説明 |
| :--- | :--- | :--- |
| `Cache-Control` | `max-age=3600` | 1時間キャッシュします。 |
| `stale-while-revalidate`| `60` | 再検証中に60秒間古い応答を許可します。 |
| `ETag` | JWKSコンテンツのハッシュ | 条件付きリクエスト用。 |

**検出（オプション）：**

自動検出をサポートするために、認証サーバーはメタデータエンドポイントを提供してもよい：

```
GET /.well-known/jts-configuration
```

**応答：**
```json
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jts-jwks",
  "token_endpoint": "https://auth.example.com/jts/login",
  "renewal_endpoint": "https://auth.example.com/jts/renew",
  "revocation_endpoint": "https://auth.example.com/jts/logout",
  "supported_profiles": ["JTS-L/v1", "JTS-S/v1", "JTS-C/v1"],
  "supported_algorithms": ["RS256", "ES256"]
}
```

#### **8.4. サポートされているアルゴリズム**

JTSは以下のアルゴリズムを推奨します：

| アルゴリズム | タイプ | 推奨 | 注 |
| :--- | :--- | :--- | :--- |
| `RS256` | 非対称 | 推奨 | SHA-256付きRSA、広くサポートされています。 |
| `RS384` | 非対称 | サポート | SHA-384付きRSA。 |
| `RS512` | 非対称 | サポート | SHA-512付きRSA。 |
| `ES256` | 非対称 | 推奨 | P-256付きECDSA、より効率的。 |
| `ES384` | 非対称 | サポート | P-384付きECDSA。 |
| `ES512` | 非対称 | サポート | P-521付きECDSA。 |
| `PS256` | 非対称 | サポート | SHA-256付きRSASSA-PSS。 |
| `HS256` | 対称 | **許可しない** | JTSの原則に合わない。 |
| `HS384` | 対称 | **許可しない** | JTSの原則に合わない。 |
| `HS512` | 対称 | **許可しない** | JTSの原則に合わない。 |
| `none` | - | **禁止** | 署名なし、非常に安全でない。 |

### **9. 同時セッションポリシー**

JTSは、単一のユーザーが複数のアクティブなセッションを持つ状況を処理するためのポリシーを定義します。

> **注意：** 同時セッションポリシーは**JTS-S**と**JTS-C**にのみ適用されます。**JTS-L**プロファイルはデフォルトで`allow_all`ポリシーのみをサポートします。

#### **9.1. ポリシーオプション**

| ポリシー | `spl`クレーム | 動作 |
| :--- | :--- | :--- |
| **すべて許可** | `allow_all` | すべてのセッションが制限なく同時に有効です。 |
| **単一** | `single` | アクティブなセッションは1つだけ。新しいログインは古いものを無効にします。|
| **最大N** | `max:3` | 最大N個のアクティブなセッション。超過した場合は最も古いものが追い出されます。|
| **通知** | `notify` | すべてのセッションは有効ですが、ユーザーには他のセッションが通知されます。|

#### **9.2. 実装**

ユーザーがログインし、ポリシーがセッション数を制限する場合：
```
1. ユーザーがログイン -> サーバーがこの`prn`のアクティブなセッション数を確認
2. カウント >= 制限の場合：
   a. "single"ポリシー：古いセッションをすべて取り消し、新しいセッションを作成
   b. "max:n"ポリシー：最も古いセッション（FIFO）を取り消し、新しいセッションを作成
3. DBに新しいセッションレコードを作成
4. StateProofとBearerPassを返す
```

#### **9.3. セッション通知**

`notify`ポリシーの場合、サーバーはアクティブなセッションを表示するためのエンドポイントを提供する必要があります：

```
GET /jts/sessions
Authorization: Bearer <BearerPass>

応答：
{
  "sessions": [
    {
      "aid": "session-anchor-abc",
      "device": "Chrome on Windows",
      "ip_prefix": "192.168.1.x",
      "created_at": 1764500000,
      "last_active": 1764515000,
      "current": true
    },
    {
      "aid": "session-anchor-def",
      "device": "Safari on iPhone",
      "ip_prefix": "10.0.0.x",
      "created_at": 1764400000,
      "last_active": 1764510000,
      "current": false
    }
  ]
}
```

### **10. マルチプラットフォームサポート**

#### **10.1. ウェブプラットフォーム（デフォルト）**

ウェブアプリケーションの場合、`StateProof`はセクション4.3に従って`HttpOnly`クッキーに保存されます。

#### **10.2. モバイル/ネイティブプラットフォーム**

クッキーが実用的でないネイティブモバイルおよびデスクトップアプリケーションの場合：

**ストレージ：**
-   **iOS:** Keychain Servicesと`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`
-   **Android:** EncryptedSharedPreferencesまたはKeystore System
-   **デスクトップ:** OS Credential Manager（Windows Credential Vault, macOS Keychain）

**StateProofの送信：**
```
POST /jts/renew
X-JTS-StateProof: <encrypted_state_proof>
Content-Type: application/json
```

**非クッキーの追加要件：**
-   `StateProof`はクライアントに保存される際に暗号化されなければなりません。
-   `X-JTS-StateProof`ヘッダーを持つリクエストは、検証のために`X-JTS-Device-ID`を含める必要があります。
-   サーバーは、`Device-ID`が初期認証中に登録されたものと一致することを検証する必要があります。

#### **10.3. サーバー間（M2M）**

マシン間通信の場合：

-   `StateProof`は使用されません（「ユーザーセッション」の概念なし）。
-   `BearerPass`はより長い`exp`で発行されます（推奨：1時間）。
-   `prn`クレームには、ユーザーではなくサービス/マシンの識別子が含まれます。
-   `atm`クレームは`client_credentials`に設定されます。

**M2Mペイロード例：**
```json
{
  "prn": "service:payment-processor",
  "aid": "m2m-static-anchor",
  "tkn_id": "token-m2m-12345",
  "aud": "https://api.example.com/internal",
  "exp": 1764519000,
  "iat": 1764515400,
  "atm": "client_credentials",
  "perm": ["internal:process_payment", "internal:read_accounts"]
}
```

### **11. 結論**

Janusトークンシステム（JTS）は、ステートレス検証の高性能とステートフルセッション管理の厳格なセキュリティコントロールを組み合わせた、バランスの取れた認証フレームワークを提供します。その2コンポーネントアーキテクチャ、明確な用語、および柔軟な運用プロファイルにより、JTSは次世代のアプリケーションのための堅牢で安全な認証標準となるように設計されています。

**さまざまなニーズに対応する3つのプロファイル：**

| プロファイル | ユースケース | 複雑さ | セキュリティ |
| :--- | :--- | :--- | :--- |
| **JTS-L（ライト）** | MVP, 内部ツール, シンプルなアプリ | ⭐ 低 | ⭐⭐ 基本 |
| **JTS-S（標準）** | 本番アプリ, 公開API | ⭐⭐ 中 | ⭐⭐⭐⭐ 高 |
| **JTS-C（機密性）**| フィンテック, ヘルスケア, 高セキュリティ | ⭐⭐⭐ 高 | ⭐⭐⭐⭐⭐ 最高 |

**従来のトークンシステムに対するJTSの利点：**
1.  **即時取消：** `StateProof`管理とトークンローテーションを通じて（JTS-S/C）。
2.  **トークン盗難検出：** リプレイを検出するローテーションメカニズムを通じて（JTS-S/C）。
3.  **階層化された保護：** CSRF保護、デバイスバインディング、およびオプションの暗号化。
4.  **エラーの標準化：** デバッグと処理のための一貫したエラーコード。
5.  **プラットフォームの柔軟性：** ウェブ、モバイル、サーバー間をサポート。
6.  **キー管理：** ダウンタイムのない明確なキーローテーション手順。
7.  **プログレッシブエンハンスメント：** アプリケーションの成長に伴うJTS-L → JTS-S → JTS-Cへの明確な移行パス。

---

### **付録A：実装チェックリスト**

実装者は、JTS準拠のために以下のチェックリストを満たす必要があります：

#### **JTS-L（ライト）チェックリスト：**

**必須（MUST）：**
- [ ] 非対称暗号を使用する（RS256, ES256など）
- [ ] すべてのBearerPassのヘッダーに`kid`を含める
- [ ] StateProofをSameSite=StrictのHttpOnlyクッキーに保存する
- [ ] `/renew`および`/logout`エンドポイントでCSRFを検証する
- [ ] 標準形式に従ってエラー応答を返す（サブセット）

**推奨（SHOULD）：**
- [ ] StateProofの有効期限を最大24時間に設定する
- [ ] `/renew`にレート制限を実装する
- [ ] すべての更新アクティビティをログに記録する

---

#### **JTS-S（標準）チェックリスト：**

**必須（MUST）：**
- [ ] 非対称暗号を使用する（RS256, ES256など）
- [ ] すべてのBearerPassのヘッダーに`kid`を含める
- [ ] StateProofをSameSite=StrictのHttpOnlyクッキーに保存する
- [ ] `/renew`ごとにStateProofのローテーションを実装する
- [ ] リプレイを検出し、検出された場合はセッションを取り消す
- [ ] `/renew`および`/logout`エンドポイントでCSRFを検証する
- [ ] 標準形式に従ってエラー応答を返す（完全）

**推奨（SHOULD）：**
- [ ] デバイスフィンガープリンティング（`dfp`）を実装する
- [ ] 飛行中のリクエストのための猶予期間をサポートする
- [ ] 可視性のために`/sessions`エンドポイントを提供する
- [ ] 同時セッションポリシーを実装する
- [ ] 異常が検出された場合にセキュリティ通知を送信する

**任意（MAY）：**
- [ ] イントロスペクションエンドポイントを実装する
- [ ] `org`クレームでマルチテナンシーをサポートする

---

#### **JTS-C（機密性）チェックリスト：**

**必須（MUST）：**
- [ ] すべてのJTS-S要件
- [ ] JWE暗号化を実装する（署名してから暗号化）
- [ ] 暗号化キーを署名キーとは別に管理する

**任意（MAY）：**
- [ ] 複数のリソースサーバー暗号化キーをサポートする
- [ ] 暗号化キーのためのキー交換プロトコルを実装する

---

### **付録B：完全なフローの例**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        JTS認証フロー                                         │
└─────────────────────────────────────────────────────────────────────────────┘

[ユーザー]      [クライアントアプリ]     [認証サーバー]        [リソースサーバー]
   │                 │                     │                      │
   │─── ログイン ──────>│                     │                      │
   │                 │─── POST /login ────>│                      │
   │                 │    (資格情報)    │                      │
   │                 │                     │── セッション作成 ───>│ [DB]
   │                 │                     │<─ セッションレコード ────│
   │                 │                     │                      │
   │                 │<── 200 OK ─────────│                      │
   │                 │    BearerPass (ボディ)│                      │
   │                 │    StateProof (クッキー)                     │
   │                 │                     │                      │
   │                 │─────────── GET /api/resource ─────────────>│
   │                 │            Authorization: Bearer <BP>      │
   │                 │                     │                      │
   │                 │                     │    署名検証  │
   │                 │                     │    (ステートレス)       │
   │                 │<────────── 200 OK ─────────────────────────│
   │<── データ ───────│                     │                      │
   │                 │                     │                      │
   │    ... BearerPassの有効期限切れ ...        │                      │
   │                 │                     │                      │
   │                 │─── POST /renew ────>│                      │
   │                 │    (StateProofクッキー)                     │
   │                 │                     │── SP_v1を検証 ───>│ [DB]
   │                 │                     │<─ 有効、消費済み ───│
   │                 │                     │── SP_v2を保存 ──────>│
   │                 │                     │                      │
   │                 │<── 200 OK ─────────│                      │
   │                 │    新しいBearerPass   │                      │
   │                 │    StateProof_v2 (クッキー)                  │
   │                 │                     │                      │
   │─── ログアウト ─────>│                     │                      │
   │                 │─── POST /logout ───>│                      │
   │                 │    (StateProofクッキー)                     │
   │                 │                     │── セッション削除 ───>│ [DB]
   │                 │<── 200 OK ─────────│                      │
   │<── ログアウト済み ─│                     │                      │
   │                 │                     │                      │
```

---

### **付録C：参考文献**

-   RFC 7519 - JSON Web Token (JWT)
-   RFC 7515 - JSON Web Signature (JWS)
-   RFC 7516 - JSON Web Encryption (JWE)
-   RFC 7517 - JSON Web Key (JWK)
-   RFC 6749 - The OAuth 2.0 Authorization Framework
-   OWASP Session Management Cheat Sheet
-   OWASP Cross-Site Request Forgery Prevention Cheat Sheet
