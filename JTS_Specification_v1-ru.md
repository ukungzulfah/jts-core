
# Архивная документация проекта: Система токенов Janus (JTS)

**Название:** Система токенов Janus (JTS): Двухкомпонентная архитектура для безопасной, отзываемой и конфиденциальной аутентификации API

**Статус:** Черновик стандарта, версия 1.1

**Автор/Пионер:** ukungzulfah

**Дата публикации:** 30 ноября 2025 г.

> **Аннотация:**
> В этом документе определяется **Система токенов Janus (JTS)**, новый стандарт аутентификации, разработанный для решения проблем безопасности и масштабируемости в современных распределенных экосистемах приложений (например, в архитектуре микросервисов). JTS вводит двухкомпонентную архитектуру, которая коренным образом разделяет **краткосрочное доказательство доступа (`BearerPass`)** и **долгосрочное доказательство сессии (`StateProof`)**. Этот подход обеспечивает чрезвычайно быструю и *независимую от состояния (stateless)* проверку доступа, сохраняя при этом жизненно важную возможность *зависимого от состояния (stateful)* управления сессиями, включая мгновенный отзыв сессии. В этом документе определены три операционных профиля: **JTS-S (стандартный)** для полной целостности с полным набором функций безопасности, **JTS-L (облегченный)** для легковесной реализации с минимальной сложностью и **JTS-C (конфиденциальный)** для полной конфиденциальности полезной нагрузки. Эта спецификация также вводит новую терминологию утверждений для замены менее интуитивных устаревших терминов.

---

### **Лицензия на авторское право**
> Copyright © 2025, ukungzulfah. Все права защищены.
>
> Настоящим предоставляется бесплатное разрешение любому лицу, получающему копию данной спецификации и сопутствующей документации («Программное обеспечение»), на использование, копирование, изменение, слияние, публикацию, распространение и/или продажу копий Программного обеспечения при соблюдении следующих условий:
>
> Вышеуказанное уведомление об авторских правах и данное разрешение должны быть включены во все копии или существенные части Программного обеспечения. ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ.

---

### **1. Введение**

#### **1.1. Проблемы современной аутентификации**
В современной архитектуре программного обеспечения приложения разбиты на небольшие независимые сервисы (микросервисы). Эта модель требует системы аутентификации, которая является легковесной, децентрализованной и не зависит от единой монолитной централизованной сессии.

#### **1.2. Ограничения моделей токенов без сохранения состояния первого поколения**
Модели аутентификации на основе токенов без сохранения состояния первого поколения предоставили частичное решение, но ввели значительные недостатки:
1.  **Уязвимость отзыва сессии:** Выданные токены не могут быть принудительно аннулированы на стороне сервера до истечения срока их действия.
2.  **Раскрытие информации:** Полезная нагрузка токена часто просто кодируется, а не шифруется, поэтому данные внутри могут быть прочитаны любой стороной, владеющей токеном.
3.  **Сложность управления ключами:** Использование общего симметричного ключа создает единую точку отказа с высоким риском в распределенной среде.

#### **1.3. Новая парадигма: Система токенов Janus (JTS)**
JTS предлагается как эволюция для устранения этих недостатков. Благодаря своему принципу дуализма, JTS сочетает в себе эффективность *без сохранения состояния* с безопасностью *с сохранением состояния*.

### **2. Основные концепции JTS**

#### **2.1. Принцип дуализма**
JTS разделяет роль токена на две:
1.  **Доступ:** Предоставление разрешения на доступ к ресурсам на очень короткий срок.
2.  **Сессия:** Подтверждение действительности общей аутентификационной сессии пользователя.

#### **2.2. Два компонента JTS**
1.  **`BearerPass`:** Криптографически подписанный, краткосрочный токен доступа. Он используется в каждом запросе API и проверяется без сохранения состояния.
2.  **`StateProof`:** Непрозрачный и сохраняющий состояние долгосрочный токен сессии. Он используется исключительно для получения нового `BearerPass` и надежно хранится на стороне клиента. Его наличие в базе данных сервера определяет действительность сессии.

### **3. Терминология и утверждения JTS**

В качестве усовершенствования JTS вводит более явную и интуитивно понятную терминологию утверждений, отходя от неоднозначных устаревших терминов.

| Утверждение JTS | Полное имя | Описание | Заменяет |
| :--- | :--- | :--- | :--- |
| **`prn`** | **Principal** | Уникальный идентификатор аутентифицированного субъекта (обычно пользователя). | `sub` |
| **`aid`** | **Anchor ID** | Уникальный идентификатор, который «привязывает» `BearerPass` к записи сессии на сервере. | `sid` |
| **`tkn_id`**| **Token ID** | Уникальный идентификатор для каждого `BearerPass`, предотвращающий атаки повторного воспроизведения. | `jti` |
| `exp` | Expiration Time | Время истечения срока действия токена (сохранено из RFC 7519). | - |
| `aud` | Audience | Предполагаемый получатель этого токена (сохранено из RFC 7519). | - |
| `iat` | Issued At | Время выдачи токена (сохранено из RFC 7519). | - |

#### **3.2. Расширенные утверждения**

JTS определяет дополнительные утверждения для более надежной безопасности и функциональности:

| Утверждение JTS | Полное имя | Описание | Требуется |
| :--- | :--- | :--- | :--- |
| **`dfp`** | **Device Fingerprint** | Хэш характеристик устройства для привязки токена к конкретному устройству. | Нет |
| **`perm`**| **Permissions** | Массив строк, определяющих разрешения/области действия, которыми обладает токен. | Нет |
| **`grc`** | **Grace Period** | Временной допуск (в секундах) после `exp` для запросов в процессе выполнения. | Нет |
| **`org`** | **Organization** | Идентификатор арендатора/организации для многопользовательских систем. | Нет |
| **`atm`** | **Auth Method** | Использованный метод аутентификации (например, `pwd`, `mfa:totp`, `sso`). | Нет |
| **`ath`** | **Auth Time** | Временная метка Unix, когда пользователь в последний раз выполнял активную аутентификацию. | Нет |
| **`spl`** | **Session Policy** | Действующая политика одновременных сессий (`allow_all`, `single`, `max:n`). | Нет |

**Пример полезной нагрузки с расширенными утверждениями:**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "tkn_id": "token-instance-98765",
  "aud": "https://api.example.com/billing",
  "exp": 1764515700,
  "iat": 1764515400,
  "dfp": "sha256:a1b2c3d4e5f6...",
  "perm": ["read:profile", "write:posts", "billing:view"],
  "grc": 30,
  "org": "tenant-acme-corp",
  "atm": "mfa:totp",
  "ath": 1764512000
}
```

### **4. Стандартный профиль: JTS-S (целостность)**

Этот профиль ориентирован на скорость, целостность и возможности отзыва сессий.

#### **4.1. Структура `BearerPass` (формат JWS)**
`BearerPass` в профиле JTS-S представляет собой **JSON Web Signature (JWS)**, подписанную с помощью **асимметричной криптографии (например, RS256)**.

**Пример заголовка:**
```json
{
  "alg": "RS256",
  "typ": "JTS-S/v1",
  "kid": "auth-server-key-2025-001"
}
```

**Примечание:** Утверждение `kid` (ID ключа) является ОБЯЗАТЕЛЬНЫМ для поддержки ротации ключей (см. раздел 7).

**Пример полезной нагрузки:**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "tkn_id": "token-instance-98765",
  "aud": "https://api.example.com/billing",
  "exp": 1764515700,
  "iat": 1764515400
}
```

#### **4.2. Рабочий процесс**
1.  **Аутентификация:** Пользователь входит в систему -> Сервер создает запись сессии в БД, генерируя `StateProof` (хранится в БД) и `BearerPass` (JWS). `StateProof` отправляется через cookie `HttpOnly`, `BearerPass` — через тело JSON.
2.  **Доступ к ресурсам:** Клиент отправляет `BearerPass` в заголовке -> Сервер проверяет подпись JWS с помощью открытого ключа.
3.  **Обновление:** `BearerPass` истекает -> Клиент вызывает конечную точку `/renew` с `StateProof` в cookie -> Сервер проверяет `StateProof` в БД; если он действителен, выдает новый `BearerPass`.
4.  **Отзыв (выход из системы):** Клиент вызывает `/logout` -> Сервер удаляет запись сессии, связанную с `StateProof`, из БД. Сессия немедленно становится недействительной.

#### **4.3. Требования к cookie и защита от CSRF**

`StateProof`, хранящийся в cookie, ДОЛЖЕН соответствовать следующим требованиям безопасности:

**ОБЯЗАТЕЛЬНЫЕ атрибуты cookie:**
```
Set-Cookie: jts_state_proof=<token>; 
  HttpOnly; 
  Secure; 
  SameSite=Strict; 
  Path=/jts; 
  Max-Age=604800
```

| Атрибут | Значение | Описание |
| :--- | :--- | :--- |
| `HttpOnly` | ОБЯЗАТЕЛЬНО | Предотвращает доступ из JavaScript (смягчает XSS). |
| `Secure` | ОБЯЗАТЕЛЬНО | Cookie отправляется только по HTTPS. |
| `SameSite` | `Strict` | Предотвращает отправку cookie при межсайтовых запросах (смягчает CSRF). |
| `Path` | `/jts` | Ограничивает отправку cookie только конечным точкам JTS. |
| `Max-Age` | Согласно политике| Срок службы cookie в соответствии с политикой сессии. |

**Дополнительная защита от CSRF:**

Для конечных точек `/renew` и `/logout` сервер ДОЛЖЕН проверять по крайней мере ОДИН из следующих механизмов:

1.  **Проверка заголовка Origin:** Убедиться, что заголовок `Origin` или `Referer` исходит из разрешенного домена.
2.  **Требование пользовательского заголовка:** Требовать пользовательский заголовок, который не может быть установлен стандартной отправкой формы:
    ```
    X-JTS-Request: 1
    ```
3.  **Шаблон двойной отправки cookie:** Отправить значение токена CSRF как в cookie, ТАК и в теле/заголовке запроса, а затем проверить их совпадение.

#### **4.4. Ротация StateProof**

Для повышения безопасности и обнаружения кражи токенов JTS ТРЕБУЕТ ротации `StateProof` при каждой операции обновления.

**Механизм:**
1.  Клиент вызывает `/renew` со старым `StateProof`.
2.  Сервер проверяет старый `StateProof` в базе данных.
3.  Если действителен:
    a.  Сервер УДАЛЯЕТ или ПОМЕЧАЕТ старый `StateProof` как *использованный*.
    b.  Сервер выдает НОВЫЙ `StateProof` и новый `BearerPass`.
    c.  Новый `StateProof` отправляется через заголовок `Set-Cookie`.
4.  Если старый `StateProof` уже помечен как *использованный* (обнаружен повтор):
    a.  Сервер ДОЛЖЕН немедленно отозвать ВСЕ сессии, связанные с этим `aid`.
    b.  Сервер ДОЛЖЕН вернуть ошибку `JTS-401-05` (Сессия скомпрометирована).
    c.  Сервер ДОЛЖЕН отправить пользователю уведомление о безопасности.

**Диаграмма ротации:**
```
[Клиент]                              [Сервер аутентификации]        [База данных]
    |                                       |                               |
    |-- POST /renew (StateProof_v1) ------->|                               |
    |                                       |-- Проверка StateProof_v1 ---->|
    |                                       |<-- Действителен, пометить как использованный ---|
    |                                       |                               |
    |                                       |-- Генерация StateProof_v2 ---->|
    |                                       |<-- Сохранен --------------------|
    |                                       |                               |
    |<-- 200 OK (новый BearerPass) ---------|                               |
    |<-- Set-Cookie: StateProof_v2 ---------|                               |
    |                                       |                               |
```

**Обнаружение аномалий (атака повторного воспроизведения):**
```
[Злоумышленник]                      [Сервер аутентификации]        [База данных]
    |                                       |                               |
    |-- POST /renew (StateProof_v1) ------->|  (украденный токен)           |
    |                                       |-- Проверка StateProof_v1 ---->|
    |                                       |<-- ИСПОЛЬЗОВАН! Обнаружен повтор -|
    |                                       |                               |
    |                                       |-- ОТОЗВАТЬ все сессии (aid) ->|
    |                                       |<-- Готово ----------------------|
    |                                       |                               |
    |<-- 401 JTS-401-05 (Скомпрометирован) ------|
    |                                       |                               |
```

#### **4.5. Обработка состояний гонки при одновременных обновлениях**

В сценариях, когда у пользователя несколько вкладок/окон или запросы на обновление происходят почти одновременно, существует риск *ложноположительного* обнаружения повтора. JTS определяет механизм **Окна льготного периода ротации** для обработки этого состояния.

**Проблема:**
```
[Вкладка A]                            [Сервер аутентификации]        [База данных]
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- Пометить SP_v1 как использованный -->|
    |                                     |                               |
[Вкладка B]  (с небольшой задержкой)    |                               |
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- Проверить SP_v1 --------------->|
    |                                     |<-- ИСПОЛЬЗОВАН! (ложное срабатывание) |
    |<-- 401 JTS-401-05 ??? --------------|  (пользователь не скомпрометирован!)      |
```

**Решение: Окно льготного периода ротации**

Сервер ДОЛЖЕН реализовать **окно льготного периода ротации** со следующими спецификациями:

1.  **Длительность окна льготного периода:** Сервер ДОЛЖЕН хранить `previous_state_proof` в течение **5-10 секунд** после ротации.
2.  **Двойная проверка:** Во время окна льготного периода сервер ДОЛЖЕН принимать КАК `current_state_proof`, ТАК и `previous_state_proof`.
3.  **Ответ на предыдущий токен:** Если запрос использует `previous_state_proof`, который все еще находится в окне льготного периода:
    -   Сервер ДОЛЖЕН вернуть ТОТ ЖЕ `StateProof` и `BearerPass`, которые уже были сгенерированы для `current_state_proof`.
    -   Сервер НЕ ДОЛЖЕН генерировать новые токены (предотвращает расхождение токенов).
4.  **После окна льготного периода:** Запрос с `previous_state_proof`, который прошел окно льготного периода, ДОЛЖЕН рассматриваться как атака повторного воспроизведения.

**Реализация базы данных:**
```sql
CREATE TABLE jts_sessions (
    aid                   VARCHAR(64) PRIMARY KEY,
    prn                   VARCHAR(128) NOT NULL,
    current_state_proof   VARCHAR(256) NOT NULL,
    previous_state_proof  VARCHAR(256),           -- Предыдущий токен
    rotation_timestamp    TIMESTAMP,              -- Когда произошла последняя ротация
    -- ... другие столбцы
);
```

**Логика проверки:**
```
function validate_state_proof(incoming_sp):
    session = db.find_by_current_sp(incoming_sp)
    if session:
        return VALID, session
    
    session = db.find_by_previous_sp(incoming_sp)
    if session:
        grace_window = 10 seconds
        if now() - session.rotation_timestamp < grace_window:
            return VALID_WITHIN_GRACE, session  // Вернуть существующие токены
        else:
            trigger_replay_detection(session.aid)
            return REPLAY_DETECTED, null
    
    return INVALID, null
```

**Диаграмма одновременного обновления (обработанная):**
```
[Вкладка A]                            [Сервер аутентификации]        [База данных]
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- Ротация: SP_v1 -> SP_v2 ---->|
    |                                     |   (сохранить previous=SP_v1)      |
    |<-- 200 OK (новый BP, SP_v2) ---------|                               |
    |                                     |                               |
[Вкладка B]  (в течение 10 секунд)       |                               |
    |-- POST /renew (SP_v1) ------------->|                               |
    |                                     |-- Проверить SP_v1 --------------->|
    |                                     |<-- Найден в previous_sp,      |
    |                                     |    в окне льготного периода -------|
    |<-- 200 OK (новый BP, SP_v2) ---------|  (те же токены, что и у Вкладки A)       |
    |                                     |                               |
```

> **Примечание:** Обе вкладки теперь имеют один и тот же `StateProof` (SP_v2), оставаясь таким образом синхронизированными.

#### **4.6. Льготный период для запросов в процессе выполнения**

Для обработки состояний гонки, когда `BearerPass` истекает во время выполнения запроса:

**Спецификация:**
-   Сервер ресурсов МОЖЕТ предоставить временной допуск (*льготный период*) после времени `exp`.
-   Льготный период НЕ ДОЛЖЕН превышать **60 секунд**.
-   Если утверждение `grc` присутствует в полезной нагрузке, его значение определяет льготный период в секундах.
-   Если утверждение `grc` отсутствует, льготный период по умолчанию составляет **0 секунд** (без допуска).

**Логика проверки:**
```
current_time = now()
effective_expiry = token.exp + token.grc (or 0 if grc is not present)

if current_time > effective_expiry:
    return ERROR_TOKEN_EXPIRED
else:
    return VALID
```

**Примечание:** Льготный период НЕ продлевает срок службы токена для целей аудита. Исходное время `exp` по-прежнему используется для ведения журнала.

### **5. Облегченный профиль: JTS-L (Lite)**

Этот профиль предназначен для случаев использования с низкой сложностью, которые требуют простоты реализации без ущерба для основных принципов безопасности JTS.

#### **5.1. Когда использовать JTS-L**

JTS-L подходит для следующих сценариев:

| Сценарий | Рекомендация | Причина |
| :--- | :--- | :--- |
| MVP стартапа / прототип | ✅ JTS-L | Быстро реализуется, позже можно обновить до JTS-S. |
| Внутренние инструменты / Панель администратора | ✅ JTS-L | Небольшая база пользователей, низкий риск. |
| Простое одностраничное приложение | ✅ JTS-L | Нет необходимости в сложной детекции повторов. |
| Публичный API с конфиденциальными данными | ❌ Использовать JTS-S| Требуется защита от повторов и привязка к устройству. |
| Финтех / Здравоохранение | ❌ Использовать JTS-S/C | Требуется максимальное соответствие и безопасность. |
| Многопользовательский SaaS | ❌ Использовать JTS-S | Требуется изоляция и полные журналы аудита. |

#### **5.2. Ключевые отличия от JTS-S**

| Функция | JTS-S (стандартный) | JTS-L (облегченный) |
| :--- | :--- | :--- |
| Ротация StateProof | ✅ ОБЯЗАТЕЛЬНО при каждом `/renew` | ❌ НЕОБЯЗАТЕЛЬНО |
| Обнаружение повторов | ✅ Встроено через маркировку использованных | ⚠️ Вручную / нет |
| Отпечаток устройства (`dfp`) | ✅ Рекомендуется | ❌ Не требуется |
| Льготный период (`grc`) | ✅ Поддерживается | ✅ Поддерживается |
| Расширенные утверждения | ✅ Полный | ⚠️ Минимальный поднабор |
| Политика одновременных сессий | ✅ Полная | ⚠️ Только `allow_all` |
| Сложность базы данных | Высокая (отслеживание использованных токенов) | Низкая (простая таблица сессий) |
| Коды ошибок | Полный (все коды) | Существенный поднабор |

#### **5.3. Структура `BearerPass` в JTS-L**

`BearerPass` в JTS-L по-прежнему использует **JWS с асимметричной криптографией**, но с более минималистичной полезной нагрузкой.

**Заголовок:**
```json
{
  "alg": "RS256",
  "typ": "JTS-L/v1",
  "kid": "auth-server-key-2025-001"
}
```

**Минимальная полезная нагрузка:**
```json
{
  "prn": "user-12345",
  "aid": "session-anchor-abcdef",
  "exp": 1764515700,
  "iat": 1764515400
}
```

**Примечание:** Утверждение `tkn_id` в JTS-L является **НЕОБЯЗАТЕЛЬНЫМ**, поскольку обнаружение повторов не требуется.

#### **5.4. Рабочий процесс JTS-L (упрощенный)**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        УПРОЩЕННЫЙ ПОТОК JTS-L                                │
└─────────────────────────────────────────────────────────────────────────────┘

[Клиент]                              [Сервер аутентификации]        [База данных]
    │                                       │                               │
    │── POST /login (учетные данные) ─────────>│                               │
    │                                       │── Создать сессию ────────────>│
    │                                       │<── ID сессии ────────────────│
    │<── 200 OK ────────────────────────────│                               │
    │    BearerPass (тело)                  │                               │
    │    StateProof (cookie)                │                               │
    │                                       │                               │
    │   ... BearerPass истекает ...          │                               │
    │                                       │                               │
    │── POST /renew (StateProof) ──────────>│                               │
    │                                       │── Проверить существование сессии ──>│
    │                                       │<── Действителен ───────────────────│
    │                                       │   (НЕТ ротации, НЕТ использованных)  │
    │<── 200 OK ────────────────────────────│                               │
    │    новый BearerPass (тело)              │                               │
    │    (StateProof без изменений)             │                               │
    │                                       │                               │
```

**Ключевые отличия:**
-   `StateProof` **НЕ ротируется** при каждом `/renew` — один и тот же токен можно использовать несколько раз, пока сессия активна.
-   Серверу нужно только проверить, **существует** ли запись сессии в базе данных, без необходимости отслеживать статус «использовано».
-   Сложность базы данных значительно снижается.

#### **5.5. Схема базы данных JTS-L**

База данных для JTS-L намного проще:

```sql
-- JTS-L: Простая таблица сессий
CREATE TABLE jts_sessions (
    aid             VARCHAR(64) PRIMARY KEY,  -- Anchor ID (StateProof)
    prn             VARCHAR(128) NOT NULL,    -- Principal (ID пользователя)
    created_at      TIMESTAMP DEFAULT NOW(),
    expires_at      TIMESTAMP NOT NULL,
    last_active     TIMESTAMP DEFAULT NOW(),
    user_agent      TEXT,                     -- Необязательно: для списка сессий
    ip_address      VARCHAR(45)               -- Необязательно: для аудита
);

-- Индекс для запроса по пользователю
CREATE INDEX idx_sessions_prn ON jts_sessions(prn);
```

**Сравните с JTS-S, который требует:**
```sql
-- JTS-S: Полная таблица сессий с отслеживанием ротации
CREATE TABLE jts_sessions (
    aid                  VARCHAR(64) PRIMARY KEY,
    prn                  VARCHAR(128) NOT NULL,
    current_state_proof  VARCHAR(256) NOT NULL,
    previous_state_proof VARCHAR(256),        -- Для окна льготного периода
    state_proof_version  INTEGER DEFAULT 1,
    consumed_at          TIMESTAMP,             -- Обнаружение повторов
    device_fingerprint   VARCHAR(128),
    created_at           TIMESTAMP DEFAULT NOW(),
    expires_at           TIMESTAMP NOT NULL,
    last_active          TIMESTAMP DEFAULT NOW(),
    -- ... больше столбцов
);

-- Дополнительная таблица для отслеживания использованных токенов
CREATE TABLE jts_consumed_tokens (
    tkn_id          VARCHAR(64) PRIMARY KEY,
    aid             VARCHAR(64) REFERENCES jts_sessions(aid),
    consumed_at     TIMESTAMP DEFAULT NOW()
);
```

#### **5.6. Поднабор кодов ошибок для JTS-L**

JTS-L ОБЯЗАН реализовать только следующий поднабор кодов ошибок:

| Код ошибки | Ключ ошибки | Описание |
| :--- | :--- | :--- |
| `JTS-400-01` | `malformed_token` | Не удалось разобрать токен. |
| `JTS-401-01` | `bearer_expired` | Срок действия BearerPass истек. |
| `JTS-401-02` | `signature_invalid` | Подпись недействительна. |
| `JTS-401-03` | `stateproof_invalid` | StateProof недействителен. |
| `JTS-401-04` | `session_terminated` | Сессия была прекращена. |

**Следующие коды ошибок НЕ требуются в JTS-L:**
-   `JTS-401-05` (session_compromised) — нет обнаружения повторов
-   `JTS-401-06` (device_mismatch) — нет привязки к устройству
-   `JTS-403-03` (org_mismatch) — нет поддержки многопользовательности

#### **5.7. Миграция с JTS-L на JTS-S**

JTS-L разработан для легкого обновления до JTS-S по мере роста требований к безопасности:

**Шаги миграции:**

1.  **Обновить тип заголовка:**
    ```json
    // До
    { "typ": "JTS-L/v1" }
    // После
    { "typ": "JTS-S/v1" }
    ```

2.  **Добавить столбцы в базу данных:**
    ```sql
    ALTER TABLE jts_sessions 
    ADD COLUMN current_state_proof VARCHAR(256),
    ADD COLUMN state_proof_version INTEGER DEFAULT 1,
    ADD COLUMN consumed_at TIMESTAMP,
    ADD COLUMN device_fingerprint VARCHAR(128);
    ```

3.  **Реализовать ротацию StateProof:** Обновить логику `/renew` для генерации нового StateProof.

4.  **Добавить `tkn_id` в полезную нагрузку:** Начать генерировать уникальный идентификатор токена для каждого BearerPass.

5.  **Постепенное внедрение:**
    -   Фаза 1: Сервер принимает как токены JTS-L, так и JTS-S
    -   Фаза 2: Все новые токены — JTS-S
    -   Фаза 3: Отклонять токены JTS-L после максимального срока жизни сессии

#### **5.8. Ограничения и риски JTS-L**

> ⚠️ **ПРЕДУПРЕЖДЕНИЕ:** Реализаторы ДОЛЖНЫ понимать следующие риски перед выбором JTS-L:

| Риск | Влияние | Смягчение |
| :--- | :--- | :--- |
| **Нет обнаружения повторов**| Украденный StateProof может быть использован несколько раз без обнаружения. | Использовать более короткий `exp` для сессии. |
| **Нет привязки к устройству** | Токен может быть использован с другого устройства. | Реализовать ограничение скорости на основе IP. |
| **Кража не обнаруживается** | Пользователь не будет уведомлен, если его токен украден. | Отслеживать шаблоны входа, уведомлять о новом IP. |

**Рекомендации по смягчению для JTS-L:**
-   Установить более короткий срок действия `StateProof` (макс. 24 часа против 7 дней в JTS-S)
-   Реализовать ограничение скорости на конечной точке `/renew`
-   Вести журнал всех действий по обновлению для ручного аудита
-   Рассмотреть возможность отправки уведомлений по электронной почте при входе с нового IP/местоположения

---

### **6. Профиль конфиденциальности: JTS-C (Confidentiality)**

Этот профиль добавляет слой шифрования для полной конфиденциальности полезной нагрузки.

#### **6.1. Структура `BearerPass` (формат JWE)**
`BearerPass` в профиле JTS-C представляет собой **JSON Web Encryption (JWE)**. Токен JWS из стандартного профиля «оборачивается» или шифруется в JWE.

#### **6.2. Рабочий процесс**
*   **Создание токена («Подписано, затем зашифровано»):**
    1.  Создать JWS, как в профиле JTS-S.
    2.  Зашифровать весь JWS с помощью **открытого ключа предполагаемого сервера ресурсов**. Результатом является JWE.
*   **Проверка токена («Расшифровано, затем проверено»):**
    1.  Сервер ресурсов получает JWE.
    2.  Сервер расшифровывает JWE с помощью **своего собственного закрытого ключа**. Результатом является исходный JWS.
    3.  Сервер проверяет JWS с помощью **открытого ключа сервера аутентификации**.

### **7. Анализ безопасности и обработка ошибок**

#### **7.1. Анализ безопасности**

*   **Отзыв сессии:** Полностью решается через управление `StateProof` в базе данных сервера.
*   **Утечка учетных данных:** Минимизируется обязательным использованием асимметричной криптографии и защитой `StateProof` в cookie `HttpOnly`.
*   **Утечка информации:** Минимизируется в JTS-S/JTS-L с минималистичной полезной нагрузкой и полностью решается в JTS-C через шифрование JWE.
*   **Атаки повторного воспроизведения:** Смягчаются с помощью уникального `tkn_id` и **ротации StateProof** в JTS-S. **Примечание:** JTS-L не обеспечивает автоматическую защиту от повторов.
*   **Атаки XSS:** Риск кражи токена сессии `StateProof` значительно снижается благодаря флагу `HttpOnly` на cookie.
*   **Атаки CSRF:** Смягчаются комбинацией `SameSite=Strict` и дополнительной проверкой заголовка.
*   **Кража токена:** Смягчается с помощью **отпечатка устройства (`dfp`)** в JTS-S. **Примечание:** JTS-L не поддерживает привязку к устройству.

#### **7.2. Стандартные коды ошибок**

JTS определяет стандартные коды ошибок для согласованности реализации и простоты отладки:

**Формат ответа об ошибке:**
```json
{
  "error": "bearer_expired",
  "error_code": "JTS-401-01",
  "message": "BearerPass has expired",
  "action": "renew",
  "retry_after": 0,
  "timestamp": 1764515800
}
```

**Список кодов ошибок:**

| Код ошибки | Статус HTTP | Ключ ошибки | Описание | Действие |
| :--- | :--- | :--- | :--- | :--- |
| `JTS-400-01` | 400 | `malformed_token` | Токен не может быть разобран или имеет неверный формат. | `reauth` |
| `JTS-400-02` | 400 | `missing_claims` | В токене отсутствуют обязательные утверждения. | `reauth` |
| `JTS-401-01` | 401 | `bearer_expired` | Срок действия BearerPass истек. | `renew` |
| `JTS-401-02` | 401 | `signature_invalid` | Подпись BearerPass недействительна. | `reauth` |
| `JTS-401-03` | 401 | `stateproof_invalid`| StateProof недействителен или не найден в БД. | `reauth` |
| `JTS-401-04` | 401 | `session_terminated`| Сессия была прекращена (выход или политика одновременности).| `reauth` |
| `JTS-401-05` | 401 | `session_compromised`| Обнаружена атака повторного воспроизведения; все сессии отозваны.| `reauth` |
| `JTS-401-06` | 401 | `device_mismatch` | Отпечаток устройства не совпадает. | `reauth` |
| `JTS-403-01` | 403 | `audience_mismatch` | Токен не предназначен для этого ресурса. | `none` |
| `JTS-403-02` | 403 | `permission_denied` | Токен не имеет необходимых разрешений. | `none` |
| `JTS-403-03` | 403 | `org_mismatch` | Токен принадлежит другой организации/арендатору. | `none` |
| `JTS-500-01` | 500 | `key_unavailable` | Открытый ключ для проверки недоступен. | `retry` |

**Значения действия:**
-   `renew`: Клиент должен вызвать конечную точку `/renew` для получения нового BearerPass.
-   `reauth`: Пользователь должен повторно аутентифицироваться (войти в систему).
-   `retry`: Запрос можно повторить через `retry_after` секунд.
-   `none`: Никакое действие не может исправить это состояние.

### **8. Управление ключами**

#### **8.1. Требование ID ключа**

Каждый `BearerPass` ДОЛЖЕН включать утверждение `kid` (ID ключа) в заголовке для идентификации ключа, использованного для подписи.

**Формат заголовка с kid:**
```json
{
  "alg": "RS256",
  "typ": "JTS-S/v1",
  "kid": "auth-server-key-2025-001"
}
```

#### **8.2. Процедура ротации ключей**

Чтобы заменить ключ подписи без аннулирования уже выданных токенов:

**Шаги:**
1.  **Сгенерировать новую пару ключей:** Создать новую пару ключей с уникальным `kid`.
2.  **Опубликовать открытый ключ:** Добавить новый открытый ключ в конечную точку JWKS. Сервер ДОЛЖЕН поддерживать несколько активных открытых ключей.
3.  **Начать подписывать новым ключом:** Все новые токены `BearerPass` подписываются новым ключом.
4.  **Вывести старый ключ из эксплуатации:** Через `max_bearer_lifetime` + буфер (рекомендация: 15 минут) удалить старый открытый ключ из JWKS.

**Ответ конечной точки JWKS:**
```json
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "auth-server-key-2025-002",
      "use": "sig",
      "alg": "RS256",
      "n": "...",
      "e": "AQAB"
    },
    {
      "kty": "RSA",
      "kid": "auth-server-key-2025-001",
      "use": "sig",
      "alg": "RS256",
      "n": "...",
      "e": "AQAB",
      "exp": 1764520000
    }
  ]
}
```

**Примечание:** Поле `exp` в записи ключа указывает, когда ключ будет выведен из эксплуатации (необязательно, для информации клиента).

#### **8.3. Стандартная конечная точка JWKS**

JTS определяет стандартный путь для конечной точки JWKS (JSON Web Key Set), чтобы серверы ресурсов могли последовательно находить открытые ключи.

**Стандартный путь:**
```
GET /.well-known/jts-jwks
```

**Требования:**

| Аспект | Спецификация |
| :--- | :--- |
| **Путь** | `/.well-known/jts-jwks` (ОБЯЗАТЕЛЬНО) |
| **Метод** | `GET` |
| **Аутентификация**| Не требуется (публичная конечная точка) |
| **Content-Type** | `application/json` |
| **CORS** | ДОЛЖЕН разрешать межсайтовые запросы из действительных доменов |

**Кэширование:**

Сервер ДОЛЖЕН включать соответствующие заголовки кэширования:

```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: public, max-age=3600, stale-while-revalidate=60
ETag: "jwks-v2-abc123"
```

| Заголовок | Рекомендуемое значение| Описание |
| :--- | :--- | :--- |
| `Cache-Control` | `max-age=3600` | Кэшировать на 1 час. |
| `stale-while-revalidate`| `60` | Разрешить устаревший ответ на 60 секунд во время перепроверки. |
| `ETag` | Хэш содержимого JWKS | Для условных запросов. |

**Обнаружение (необязательно):**

Для поддержки автоматического обнаружения сервер аутентификации МОЖЕТ предоставить конечную точку метаданных:

```
GET /.well-known/jts-configuration
```

**Ответ:**
```json
{
  "issuer": "https://auth.example.com",
  "jwks_uri": "https://auth.example.com/.well-known/jts-jwks",
  "token_endpoint": "https://auth.example.com/jts/login",
  "renewal_endpoint": "https://auth.example.com/jts/renew",
  "revocation_endpoint": "https://auth.example.com/jts/logout",
  "supported_profiles": ["JTS-L/v1", "JTS-S/v1", "JTS-C/v1"],
  "supported_algorithms": ["RS256", "ES256"]
}
```

#### **8.4. Поддерживаемые алгоритмы**

JTS рекомендует следующие алгоритмы:

| Алгоритм | Тип | Рекомендация | Примечания |
| :--- | :--- | :--- | :--- |
| `RS256` | Асимметричный | РЕКОМЕНДУЕТСЯ | RSA с SHA-256, широко поддерживается. |
| `RS384` | Асимметричный | ПОДДЕРЖИВАЕТСЯ | RSA с SHA-384. |
| `RS512` | Асимметричный | ПОДДЕРЖИВАЕТСЯ | RSA с SHA-512. |
| `ES256` | Асимметричный | РЕКОМЕНДУЕТСЯ | ECDSA с P-256, более эффективен. |
| `ES384` | Асимметричный | ПОДДЕРЖИВАЕТСЯ | ECDSA с P-384. |
| `ES512` | Асимметричный | ПОДДЕРЖИВАЕТСЯ | ECDSA с P-521. |
| `PS256` | Асимметричный | ПОДДЕРЖИВАЕТСЯ | RSASSA-PSS с SHA-256. |
| `HS256` | Симметричный | **НЕ РАЗРЕШЕНО** | Не соответствует принципам JTS. |
| `HS384` | Симметричный | **НЕ РАЗРЕШЕНО** | Не соответствует принципам JTS. |
| `HS512` | Симметричный | **НЕ РАЗРЕШЕНО** | Не соответствует принципам JTS. |
| `none` | - | **ЗАПРЕЩЕНО** | Без подписи, крайне небезопасно. |

### **9. Политика одновременных сессий**

JTS определяет политики для обработки ситуаций, когда у одного пользователя несколько активных сессий.

> **Примечание:** Политики одновременных сессий применяются только к **JTS-S** и **JTS-C**. Профиль **JTS-L** по умолчанию поддерживает только политику `allow_all`.

#### **9.1. Варианты политики**

| Политика | Утверждение `spl` | Поведение |
| :--- | :--- | :--- |
| **Разрешить все** | `allow_all` | Все сессии действительны одновременно без ограничений. |
| **Единственная** | `single` | Только одна активная сессия. Новый вход аннулирует старый. |
| **Максимум N** | `max:3` | Максимум N активных сессий. Самая старая вытесняется при превышении. |
| **Уведомлять** | `notify` | Все сессии действительны, но пользователь уведомляется о других. |

#### **9.2. Реализация**

Когда пользователь входит в систему, и политика ограничивает количество сессий:
```
1. Пользователь входит в систему -> Сервер проверяет количество активных сессий для этого `prn`
2. Если количество >= лимиту:
   a. Политика "single": Отозвать все старые сессии, создать новую
   b. Политика "max:n": Отозвать самую старую сессию (FIFO), создать новую
3. Создать новую запись сессии в БД
4. Вернуть StateProof и BearerPass
```

#### **9.3. Уведомление о сессии**

Для политики `notify` сервер ДОЛЖЕН предоставить конечную точку для просмотра активных сессий:

```
GET /jts/sessions
Authorization: Bearer <BearerPass>

Ответ:
{
  "sessions": [
    {
      "aid": "session-anchor-abc",
      "device": "Chrome on Windows",
      "ip_prefix": "192.168.1.x",
      "created_at": 1764500000,
      "last_active": 1764515000,
      "current": true
    },
    {
      "aid": "session-anchor-def",
      "device": "Safari on iPhone",
      "ip_prefix": "10.0.0.x",
      "created_at": 1764400000,
      "last_active": 1764510000,
      "current": false
    }
  ]
}
```

### **10. Поддержка нескольких платформ**

#### **10.1. Веб-платформа (по умолчанию)**

Для веб-приложений `StateProof` хранится в cookie `HttpOnly` в соответствии с разделом 4.3.

#### **10.2. Мобильные/нативные платформы**

Для нативных мобильных и настольных приложений, где cookie непрактичны:

**Хранение:**
-   **iOS:** Keychain Services с `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`
-   **Android:** EncryptedSharedPreferences или Keystore System
-   **Настольные:** Диспетчер учетных данных ОС (Windows Credential Vault, macOS Keychain)

**Отправка StateProof:**
```
POST /jts/renew
X-JTS-StateProof: <encrypted_state_proof>
Content-Type: application/json
```

**Дополнительные требования для не-cookie:**
-   `StateProof` ДОЛЖЕН быть зашифрован при хранении на клиенте.
-   Запросы с заголовком `X-JTS-StateProof` ДОЛЖНЫ включать `X-JTS-Device-ID` для проверки.
-   Сервер ДОЛЖЕН проверять, что `Device-ID` соответствует зарегистрированному во время первоначальной аутентификации.

#### **10.3. Сервер-сервер (M2M)**

Для межмашинного взаимодействия:

-   `StateProof` НЕ используется (нет концепции «сессии пользователя»).
-   `BearerPass` выдается с более длительным `exp` (рекомендация: 1 час).
-   Утверждение `prn` содержит идентификатор службы/машины, а не пользователя.
-   Утверждение `atm` установлено в `client_credentials`.

**Пример полезной нагрузки M2M:**
```json
{
  "prn": "service:payment-processor",
  "aid": "m2m-static-anchor",
  "tkn_id": "token-m2m-12345",
  "aud": "https://api.example.com/internal",
  "exp": 1764519000,
  "iat": 1764515400,
  "atm": "client_credentials",
  "perm": ["internal:process_payment", "internal:read_accounts"]
}
```

### **11. Заключение**

Система токенов Janus (JTS) предлагает сбалансированную структуру аутентификации, сочетающую высокую производительность проверки без сохранения состояния со строгими мерами безопасности управления сессиями с сохранением состояния. Благодаря своей двухкомпонентной архитектуре, четкой терминологии и гибким операционным профилям, JTS разработана как надежный и безопасный стандарт аутентификации для следующего поколения приложений.

**Три профиля для различных нужд:**

| Профиль | Вариант использования | Сложность | Безопасность |
| :--- | :--- | :--- | :--- |
| **JTS-L (облегченный)** | MVP, внутренние инструменты, простые приложения | ⭐ Низкая | ⭐⭐ Базовая |
| **JTS-S (стандартный)** | Промышленные приложения, публичные API | ⭐⭐ Средняя | ⭐⭐⭐⭐ Высокая |
| **JTS-C (конфиденциальный)**| Финтех, здравоохранение, высокая безопасность | ⭐⭐⭐ Высокая | ⭐⭐⭐⭐⭐ Максимальная |

**Преимущества JTS по сравнению с системами токенов предыдущего поколения:**
1.  **Мгновенный отзыв:** Через управление `StateProof` и ротацию токенов (JTS-S/C).
2.  **Обнаружение кражи токенов:** Через механизм ротации, который обнаруживает повторы (JTS-S/C).
3.  **Многоуровневая защита:** Защита от CSRF, привязка к устройству и необязательное шифрование.
4.  **Стандартизация ошибок:** Единые коды ошибок для отладки и обработки.
5.  **Гибкость платформы:** Поддержка веб, мобильных и сервер-серверных приложений.
6.  **Управление ключами:** Четкая процедура ротации ключей без простоев.
7.  **Прогрессивное улучшение:** Четкий путь миграции от JTS-L → JTS-S → JTS-C по мере роста приложения.

---

### **Приложение A: Контрольный список реализации**

Реализаторы ДОЛЖНЫ соответствовать следующему контрольному списку для соответствия JTS:

#### **Контрольный список JTS-L (облегченный):**

**Обязательно (ДОЛЖЕН):**
- [ ] Использовать асимметричную криптографию (RS256, ES256 и т.д.)
- [ ] Включать `kid` в заголовок каждого BearerPass
- [ ] Хранить StateProof в cookie HttpOnly с SameSite=Strict
- [ ] Проверять CSRF на конечных точках `/renew` и `/logout`
- [ ] Возвращать ответы об ошибках в соответствии со стандартным форматом (поднабор)

**Рекомендуется (СЛЕДУЕТ):**
- [ ] Установить срок действия StateProof не более 24 часов
- [ ] Реализовать ограничение скорости на `/renew`
- [ ] Вести журнал всех действий по обновлению

---

#### **Контрольный список JTS-S (стандартный):**

**Обязательно (ДОЛЖЕН):**
- [ ] Использовать асимметричную криптографию (RS256, ES256 и т.д.)
- [ ] Включать `kid` в заголовок каждого BearerPass
- [ ] Хранить StateProof в cookie HttpOnly с SameSite=Strict
- [ ] Реализовать ротацию StateProof при каждом `/renew`
- [ ] Обнаруживать повторы и отзывать сессии при обнаружении
- [ ] Проверять CSRF на конечных точках `/renew` и `/logout`
- [ ] Возвращать ответы об ошибках в соответствии со стандартным форматом (полный)

**Рекомендуется (СЛЕДУЕТ):**
- [ ] Реализовать отпечаток устройства (`dfp`)
- [ ] Поддерживать льготные периоды для запросов в процессе выполнения
- [ ] Предоставить конечную точку `/sessions` для наглядности
- [ ] Реализовать политики одновременных сессий
- [ ] Отправлять уведомления о безопасности при обнаружении аномалий

**Необязательно (МОЖЕТ):**
- [ ] Реализовать конечную точку интроспекции
- [ ] Поддерживать многопользовательность с утверждением `org`

---

#### **Контрольный список JTS-C (конфиденциальный):**

**Обязательно (ДОЛЖЕН):**
- [ ] Все требования JTS-S
- [ ] Реализовать шифрование JWE (подписано, затем зашифровано)
- [ ] Управлять ключами шифрования отдельно от ключей подписи

**Необязательно (МОЖЕТ):**
- [ ] Поддерживать несколько ключей шифрования сервера ресурсов
- [ ] Реализовать протокол обмена ключами для ключей шифрования

---

### **Приложение B: Пример полного потока**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ПОТОК АУТЕНТИФИКАЦИИ JTS                              │
└─────────────────────────────────────────────────────────────────────────────┘

[Пользователь]  [Клиентское приложение][Сервер аутентификации][Сервер ресурсов]
   │                 │                     │                      │
   │─── Вход ─────────>│                     │                      │
   │                 │─── POST /login ────>│                      │
   │                 │    (учетные данные)  │                      │
   │                 │                     │── Создать сессию ───>│ [БД]
   │                 │                     │<─ Запись сессии ────│
   │                 │                     │                      │
   │                 │<── 200 OK ─────────│                      │
   │                 │    BearerPass (тело)│                      │
   │                 │    StateProof (cookie)                     │
   │                 │                     │                      │
   │                 │─────────── GET /api/resource ─────────────>│
   │                 │            Authorization: Bearer <BP>      │
   │                 │                     │                      │
   │                 │                     │    Проверить подпись │
   │                 │                     │    (без сохранения состояния)       │
   │                 │<────────── 200 OK ─────────────────────────│
   │<── Данные ───────│                     │                      │
   │                 │                     │                      │
   │    ... BearerPass истекает ...      │                      │
   │                 │                     │                      │
   │                 │─── POST /renew ────>│                      │
   │                 │    (StateProof cookie)                     │
   │                 │                     │── Проверить SP_v1 ───>│ [БД]
   │                 │                     │<─ Действителен, использован ──│
   │                 │                     │── Сохранить SP_v2 ──>│
   │                 │                     │                      │
   │                 │<── 200 OK ─────────│                      │
   │                 │    новый BearerPass   │                      │
   │                 │    StateProof_v2 (cookie)                  │
   │                 │                     │                      │
   │─── Выход ────────>│                     │                      │
   │                 │─── POST /logout ───>│                      │
   │                 │    (StateProof cookie)                     │
   │                 │                     │── Удалить сессию ───>│ [БД]
   │                 │<── 200 OK ─────────│                      │
   │<── Вышел из системы│                     │                      │
   │                 │                     │                      │
```

---

### **Приложение C: Ссылки**

-   RFC 7519 - JSON Web Token (JWT)
-   RFC 7515 - JSON Web Signature (JWS)
-   RFC 7516 - JSON Web Encryption (JWE)
-   RFC 7517 - JSON Web Key (JWK)
-   RFC 6749 - The OAuth 2.0 Authorization Framework
-   OWASP Session Management Cheat Sheet
-   OWASP Cross-Site Request Forgery Prevention Cheat Sheet
